My name is Nuzhat Saba, and I’m from Jharkhand. I am currently working as an AWS DevOps Engineer, where I have hands-on experience with major AWS services such as ECS, EKS, EC2, RDS, Load Balancers, S3, and IAM.
In addition to AWS, I work with a wide range of DevOps tools — including Terraform and CloudFormation for Infrastructure as Code, Ansible for configuration management,
ELK stack for logging, and Prometheus with Grafana for monitoring.

Infrastructure Management
Provision and Manage AWS Resources: Use AWS Management Console, CLI, or Infrastructure as Code (IaC) tools like Terraform or AWS CloudFormation to create and manage resources such as EC2 instances, S3 buckets, RDS databases, and VPCs.
Configure Networking: Set up and maintain VPC configurations, subnets, route tables, security groups, and network ACLs to ensure secure and efficient network traffic.
Patch and Update Systems: Apply security patches and updates to EC2 instances, containers, or serverless components, ensuring compliance with organizational policies.

CI/CD Pipeline Maintenance

Build and Maintain Pipelines: Configure and troubleshoot CI/CD pipelines using AWS CodePipeline, CodeBuild, and CodeDeploy to automate software builds, testing, and deployments.
Integrate Version Control: Work with Git repositories (e.g., AWS CodeCommit, GitHub, or Bitbucket) to manage code versioning and integrate with CI/CD workflows.
Automate Deployments: Deploy applications to environments like ECS, EKS, or Lambda, ensuring minimal downtime and rollback capabilities.

Automation and Scripting

Write Automation Scripts: Develop scripts in Python, Bash, or PowerShell to automate repetitive tasks such as resource provisioning, log analysis, or backup scheduling.
Use AWS SDKs: Leverage AWS SDKs (e.g., Boto3 for Python) to automate interactions with AWS services like S3, DynamoDB, or SNS.
Implement IaC: Write and maintain Terraform scripts or CloudFormation templates to provision and update infrastructure in a repeatable, version-controlled manner.

Monitoring and Logging

Set Up Monitoring: Configure AWS CloudWatch to monitor metrics, set alarms for CPU usage, memory, or application errors, and create dashboards for real-time visibility.
Log Management: Centralize and analyze logs using CloudWatch Logs, ELK Stack, or third-party tools to troubleshoot issues and identify performance bottlenecks.
Incident Response: Respond to alerts, investigate issues using logs and metrics, and perform root cause analysis for outages or performance degradation.

Security and Compliance

Manage IAM Policies: Create and manage IAM roles, users, and policies to enforce least privilege access for AWS resources and team members.
Secure Infrastructure: Implement security best practices, such as enabling MFA, encrypting S3 buckets, and configuring SSL/TLS for application endpoints.
Compliance Checks: Run AWS Config or Trusted Advisor to ensure resources comply with organizational and industry standards (e.g., SOC 2, HIPAA).

Collaboration and Documentation

Collaborate with Teams: Work with developers, QA, and product teams to understand application requirements and optimize deployment processes.
Document Processes: Maintain documentation for infrastructure setups, CI/CD pipelines, and runbooks for incident response using tools like Confluence or wikis.
Participate in Standups: Attend daily standup meetings to discuss ongoing tasks, blockers, and upcoming sprints, ensuring alignment with team goals.

Optimization and Cost Management

Optimize Resources: Analyze resource usage with AWS Cost Explorer or Trusted Advisor to right-size EC2 instances, optimize S3 storage classes, or schedule non-production resources to save costs.
Implement Auto-Scaling: Configure auto-scaling groups for EC2 or ECS to handle variable workloads efficiently.
Performance Tuning: Optimize application performance by adjusting CloudFront distributions, RDS configurations, or Lambda memory settings.

Learning and Improvement

Stay Updated: Keep up with AWS service updates, new features, and best practices through AWS blogs, re:Invent sessions, or certifications (e.g., AWS Certified DevOps Engineer – Professional).
Experiment with Tools: Explore new AWS services or third-party tools (e.g., Docker, Kubernetes, or Jenkins) to improve workflows and propose enhancements.
Participate in Post-Mortems: Contribute to post-incident reviews to identify improvements in processes, tools, or infrastructure.

Sample Daily Schedule

Morning:

Review CloudWatch alarms and incident tickets from overnight.
Check CI/CD pipeline status for failed builds or deployments.
Attend daily standup to discuss priorities and blockers.

Midday:

Work on provisioning new resources or updating IaC templates.
Troubleshoot application issues reported by developers or monitoring tools.
Collaborate with team members on pipeline improvements or security configurations.

Afternoon:

Test and deploy application updates via CodePipeline.
Optimize resources or review cost reports for inefficiencies.
Document processes or update runbooks for new setups.

End of Day:

Validate backups and ensure scheduled jobs (e.g., snapshots, Lambda triggers) ran successfully.
Plan tasks for the next day and update tickets in tools like Jira.
